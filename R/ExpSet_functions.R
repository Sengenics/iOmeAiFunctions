#' Extract Components from an ExpressionSet List (i-Ome AI)
#'
#' This function extracts the expression matrix, phenotype data, and feature data
#' from a named ExpressionSet object within a list generated by i-Ome AI.
#'
#' - The `data` parameter controls sample inclusion:
#'     - `"clinical"`: only clinical samples
#'     - `"sample"`: full dataset, including technical replicates
#' - The `normalisation` parameter defines preprocessing:
#'     - `"loess_normalisation"` or `"median_normalisation"`
#' - If `ComBat = TRUE`, batch correction is applied by extracting the ComBat-adjusted matrix.
#' - The `ncf_select` option determines feature filtering based on the `ncf` column in featureData:
#'     - `"all"`: include all features
#'     - `"retain"`: include only features where `ncf == 'retain'`
#'     - `"filter"`: include only features where `ncf == 'filter'`
#'
#' @param ExpSet_list A named list of ExpressionSet objects.
#' @param data Character; either `"clinical"` or `"sample"`.
#' @param normalisation Character; either `"loess_normalisation"` or `"median_normalisation"`.
#' @param ComBat Logical; whether to extract batch-corrected data.
#' @param ncf_select Character; one of `"all"`, `"retain"`, or `"filter"` to filter features by `ncf`.
#'
#' @return A list containing:
#'   - \code{m}: The selected expression matrix from assayData.
#'   - \code{metadata}: Sample-level metadata (phenotype data).
#'   - \code{features}: Feature-level metadata.
#'   - \code{ExpSet}: The full ExpressionSet object (possibly filtered).
#'
#' @import dplyr
#' @import Biobase
#' @importFrom magrittr %>%
#'
#' @examples
#' result <- ExpSet_list_extract_function(my_ExpSet_list, "clinical", "loess_normalisation", TRUE, "retain")
#' @export
ExpSet_list_extract_function <- function(ExpSet_list,
																				 data = 'clinical',
																				 normalisation = 'loess_normalised',
																				 ComBat = FALSE,
																				 ncf_select = 'retain') {

	# Build ExpressionSet name
	ExpSet_name <- paste0(data, '_ExpSet')
	ExpSet <- ExpSet_list[[ExpSet_name]]

	# Build matrix name
	matrix_name <- paste0(data, "_", normalisation)
	if (ComBat) {
		matrix_name <- paste0(matrix_name, '_ComBat')
	}

	# Filter features by `ncf`, if required
	if (!identical(ncf_select, 'all')) {
		ncf_features <- fData(ExpSet) %>%
			filter(ncf == ncf_select) %>%
			pull(Protein)
		ExpSet <- ExpSet[ncf_features, ]
	}

	return(list(
		m = ExpSet@assayData[[matrix_name]],
		metadata = pData(ExpSet),
		features = fData(ExpSet),
		ExpSet = ExpSet
	))
}


#' Add Columns to phenoData (pData) of an ExpressionSet
#'
#' Merges new metadata columns into the `pData` slot of an `ExpressionSet` object.
#'
#' @param ExpSet An `ExpressionSet` object.
#' @param meta_add A data frame with `Sample` and columns to add.
#' @param add_cols Character vector of column names from `meta_add` to add to `pData`.
#'
#' @return The updated `ExpressionSet` object with modified `pData`.
#'
#' @note
#' Version 1.0 from
#' ExpSet_functions.R
#' @export
ExpSet_add_pData_function <- function(ExpSet, meta_add, add_cols) {
	print(phenoData(ExpSet))

	meta <- pData(ExpSet)

	cat(paste('\nAdd Metadata column(s):', paste(add_cols, collapse = ', '), '\n\n'))

	meta <- meta %>%
		dplyr::select(-any_of(add_cols)) %>%
		left_join(meta_add %>% dplyr::select(any_of(c("Sample", add_cols))), by = "Sample") %>%
		mutate(row_name = Sample) %>%
		column_to_rownames("row_name")

	pData(ExpSet) <- meta
	print(phenoData(ExpSet))

	return(ExpSet)
}


#' Add Columns to featureData (fData) of an ExpressionSet
#'
#' Merges new feature metadata columns into the `fData` slot of an `ExpressionSet` object.
#'
#' @param ExpSet An `ExpressionSet` object.
#' @param meta_add A data frame with `Protein` and columns to add.
#' @param add_cols Character vector of column names from `meta_add` to add to `fData`.
#'
#' @return The updated `ExpressionSet` object with modified `fData`.
#'
#' @note
#' Version 1.0 from
#' ExpSet_functions.R
#' @export
ExpSet_add_fData_function <- function(ExpSet, meta_add, add_cols, feature_column = 'Protein') {
	print(featureData(ExpSet))

	meta <- fData(ExpSet)

	cat(paste('\nAdd Metadata column(s):', paste(add_cols, collapse = ', '), '\n\n'))

	meta <- meta %>%
		dplyr::select(-any_of(add_cols)) %>%
		left_join(meta_add %>% dplyr::select(any_of(c(feature_column, add_cols))), by = feature_column) %>%
		mutate(row_name = !!sym(feature_column)) %>%
		column_to_rownames("row_name")

	fData(ExpSet) <- meta
	print(featureData(ExpSet))

	return(ExpSet)
}


#' Select ExpressionSet and Set exprs()
#'
#' Helper function to extract ExpressionSet from list and set exprs() to selected assay
#'
#' @param ExpSet_list List; list of ExpressionSets
#' @param name Character; name of assay to use (e.g., "clinical_loess_normalised")
#'
#' @return ExpressionSet with exprs() set to selected assay
#' @export
ExpSet_select_function_2 <- function(ExpSet_list, name) {
	
	if (is.null(ExpSet_list)) {
		return(NULL)
	}
	
	# Get the ExpressionSet name (e.g., "clinical_ExpSet")
	ExpSet_name <- get_ExpSet_name(name, ExpSet_list)
	
	# Extract the ExpressionSet
	ExpSet <- ExpSet_list[[ExpSet_name]]
	
	# Store the assay name in metadata
	ExpSet@experimentData@other$name <- name
	
	# Set exprs() to the selected assay (unless it's already "exprs")
	if (name != "exprs") {
		Biobase::exprs(ExpSet) <- ExpSet@assayData[[name]]
	}
	
	return(ExpSet)
}


#' Get ExpressionSet Name from Assay Name
#'
#' Helper function to determine which ExpressionSet contains the requested assay
#'
#' @param name Character; assay name (e.g., "clinical_loess_normalised")
#' @param ExpSet_list List; list of ExpressionSets
#'
#' @return Character; name of ExpressionSet containing the assay
#' @keywords internal
get_ExpSet_name <- function(name, ExpSet_list) {
	
	# Parse the name to get the prefix (e.g., "clinical" from "clinical_loess_normalised")
	# Assumes format: {dataset}_{normalization_method}
	
	parts <- strsplit(name, "_")[[1]]
	
	# Common prefixes
	possible_prefixes <- c("clinical", "sample", "imputed")
	
	for (prefix in possible_prefixes) {
		eset_name <- paste0(prefix, "_ExpSet")
		if (eset_name %in% names(ExpSet_list)) {
			# Check if this ExpSet contains the requested assay
			if (name %in% names(ExpSet_list[[eset_name]]@assayData)) {
				return(eset_name)
			}
		}
	}
	
	# If not found with common prefixes, search all ExpressionSets
	for (eset_name in names(ExpSet_list)) {
		if (name %in% names(ExpSet_list[[eset_name]]@assayData)) {
			return(eset_name)
		}
	}
	
	# Default to first ExpressionSet if nothing found
	warning(paste("Assay", name, "not found. Using first ExpressionSet."))
	return(names(ExpSet_list)[1])
}


#' Create Matrix from Long Format Data
#'
#' @description
#' Converts long format data to a matrix with proper row and column ordering.
#'
#' @param data A data frame in long format
#' @param sample_col Character. Name of the column containing sample identifiers (default: "Sample")
#' @param feature_col Character. Name of the column containing feature identifiers
#' @param value_col Character. Name of the column containing values
#'
#' @return A matrix with features as rows and samples as columns, sorted alphabetically
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' data <- data.frame(
#'   Sample = rep(c("S1", "S2"), each = 3),
#'   Protein = rep(c("P1", "P2", "P3"), 2),
#'   value = rnorm(6)
#' )
#' mat <- ExpSet_create_matrix(data, feature_col = "Protein", value_col = "value")
#' }
ExpSet_create_matrix <- function(data, sample_col = "Sample", feature_col, value_col) {
  data %>%
    dplyr::select(dplyr::all_of(c(sample_col, feature_col, value_col))) %>%
    tidyr::spread(key = !!rlang::sym(sample_col), value = !!rlang::sym(value_col)) %>%
    tibble::column_to_rownames(feature_col) %>%
    as.matrix() %>%
    .[order(rownames(.)), order(colnames(.))]
}


#' Create Feature Data for ExpressionSet
#'
#' @description
#' Creates an AnnotatedDataFrame for feature data with optional PSA list annotation.
#'
#' @param data A data frame containing feature information
#' @param feature_df A data frame with additional feature annotations
#' @param PSA_list Optional character vector of proteins in PSA list
#' @param feature_col Character. Name of the feature column (default: "Protein")
#'
#' @return An AnnotatedDataFrame object with feature metadata
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' data <- data.frame(Protein = c("P1", "P2"), data = c("A", "B"))
#' feature_df <- data.frame(Protein = c("P1", "P2"), Gene = c("G1", "G2"))
#' features <- ExpSet_create_feature_data(data, feature_df)
#' }
ExpSet_create_feature_data <- function(data, feature_df, PSA_list = NULL, feature_col = "Protein") {
  feature_info <- data %>%
    dplyr::select(dplyr::all_of(c(feature_col, "data"))) %>%
    dplyr::distinct()

  if (!is.null(PSA_list)) {
    feature_info <- feature_info %>%
      dplyr::mutate(PSA_list = ifelse(!!rlang::sym(feature_col) %in% PSA_list, 'PSA list', ''))
  }

  # Remove overlapping columns EXCEPT the join column
  cols_to_remove <- setdiff(names(feature_info), feature_col)

  feature_info %>%
    dplyr::left_join(
      feature_df %>% dplyr::select(-any_of(cols_to_remove)),
      by = feature_col
    ) %>%
    mutate(row_names = !!rlang::sym(feature_col)) %>%
    tibble::column_to_rownames('row_names') %>%
    Biobase::AnnotatedDataFrame()
}


#' Create Metadata for ExpressionSet
#'
#' @description
#' Creates an AnnotatedDataFrame for phenotype data (metadata) with sample type classification.
#'
#' @param datCollate A list containing data collation results
#' @param manifest_full A data frame with complete manifest including QC information
#'
#' @return An AnnotatedDataFrame object with sample metadata
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' metadata <- ExpSet_create_metadata(datCollate, manifest_full)
#' }
ExpSet_create_metadata <- function(datCollate, manifest_full) {
  metadata <- datCollate$data$manifest %>%
    dplyr::mutate(Sample_type = dplyr::case_when(
      Labels %in% datCollate$param$TR_label ~ 'TR',
      Labels %in% datCollate$param$BOC_label ~ 'BOC',
      TRUE ~ 'Sample'
    )) %>%
    dplyr::left_join(manifest_full %>% dplyr::select(Sample, QC), by = "Sample") %>%
    mutate(row_names = Sample) %>%
    tibble::column_to_rownames('row_names') %>%
    Biobase::AnnotatedDataFrame()

  return(metadata)
}


#' Build Other Metadata Structure
#'
#' @description
#' Creates the "other" metadata structure for ExpressionSet experimentData.
#'
#' @param dat Data preprocessing list containing param and other elements
#' @param datCollate Data collation list containing param, QC, and other elements
#' @param QC QC list containing param, BGFG_stats, Avg_QC, and other elements
#' @param project_info Project information to include in metadata
#'
#' @return A list containing organized metadata including parameters, QC data, and manifest
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' other <- ExpSet_build_other_metadata(dat, datCollate, QC, project_information())
#' }
ExpSet_build_other_metadata <- function(dat, datCollate, QC = NULL, project_info = NULL) {
  other <- list()

  # Parameters
  other$parameters <- list(
    dat = dat$param,
    datCollate = datCollate$param,
    QC = if (!is.null(QC)) QC$param else NULL,
    WorkOrder = project_info
  )

  # QC data
  if (!is.null(QC)) {
    other$BGFG_stats <- QC$BGFG_stats
    other$Avg_QC <- QC$Avg_QC
  }

  if (!is.null(datCollate$QC)) {
    other$QC$PerSample <- datCollate$QC$PerSample_QC
    other$QC$PerProtein <- datCollate$QC$PerProtein_QC
  }

  # Additional data
  other$manifest_full <- datCollate$output$manifest
  if (!is.null(datCollate$data$Isolated_Data)) {
    other$data$Isolated_Data <- datCollate$data$Isolated_Data
  }

  return(other)
}


#' Create Raw Data ExpressionSet
#'
#' @description
#' Creates an ExpressionSet containing raw intensity data (BG, FG, NetI).
#'
#' @param datCollate A list containing data collation results
#' @param metadata An AnnotatedDataFrame with sample metadata
#' @param params A list of parameters used in preprocessing
#'
#' @return An ExpressionSet object with raw data assays
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' expset <- ExpSet_create_rawdata(datCollate, metadata, params)
#' }
ExpSet_create_rawdata <- function(datCollate, metadata, params) {
  RawData <- datCollate$data$RawData
  feature_df <- datCollate$data$feature_df

  # Create feature data
  Raw_features <- RawData %>%
    dplyr::select(spot, Protein) %>%
    dplyr::distinct() %>%
    dplyr::left_join(feature_df, by = "Protein") %>%
    dplyr::filter(!duplicated(spot)) %>%
    tibble::column_to_rownames('spot') %>%
    Biobase::AnnotatedDataFrame()

  # Create matrices
  BG <- ExpSet_create_matrix(RawData, feature_col = "spot", value_col = "BG")
  FG <- ExpSet_create_matrix(RawData, feature_col = "spot", value_col = "FG")
  NetI <- ExpSet_create_matrix(RawData, feature_col = "spot", value_col = "NetI")

  # Create ExpressionSet with NetI as initial exprs
  expset <- Biobase::ExpressionSet(
    assayData = NetI,
    phenoData = metadata[colnames(NetI), ],
    featureData = Raw_features[rownames(NetI), ]
  )

  # Add all assay data
  Biobase::assayData(expset) <- Biobase::assayDataNew(
    RawData_BG = BG,
    RawData_FG = FG,
    RawData_NetI = NetI
  )

  expset@experimentData@other$params <- params$dat
  return(expset)
}


#' Create Mean ExpressionSet
#'
#' @description
#' Creates an ExpressionSet containing mean intensity values with CV and CV_flagged.
#'
#' @param datCollate A list containing data collation results
#' @param metadata An AnnotatedDataFrame with sample metadata
#' @param params A list of parameters used in preprocessing
#' @param PSA_list Optional character vector of proteins in PSA list
#'
#' @return An ExpressionSet object with mean data assays
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' expset <- ExpSet_create_mean(datCollate, metadata, params)
#' }
#'
#'
ExpSet_create_mean <- function(datCollate, metadata, params, PSA_list = NULL) {
  Data <- datCollate$data$Data

  # Create feature data
  features <- ExpSet_create_feature_data(Data, datCollate$data$feature_df, PSA_list)

  # Create matrices
  MeanNetI <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "mean")
  log2MeanNetI <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "log2_mean")
  CV <- round(ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "cv"),3)

  # source <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "source")
  # #Create CV_flagged: use flag values where num_test is NA, otherwise use cv values
  # num_test <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "num_test")
  # Flagged <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "flag")
  # flag <- source
  # flag[is.na(num_test)] <- Flagged[is.na(num_test)]

  # Create ExpressionSet with MeanNetI as initial exprs
  expset <- Biobase::ExpressionSet(
    assayData = MeanNetI,
    phenoData = metadata[colnames(MeanNetI), ],
    featureData = features[rownames(MeanNetI), ]
  )

  # Add all assay data
  Biobase::assayData(expset) <- Biobase::assayDataNew(
    mean_MeanNetI = MeanNetI,
    mean_log2MeanNetI = log2MeanNetI,
    cv = CV,
    flag = flag_function(Data)
  )

  expset@experimentData@other$params <- params
  return(expset)
}


flag_function = function(Data){
  source <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "source")
  #Create CV_flagged: use flag values where num_test is NA, otherwise use cv values
  num_test <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "num_test")
  Flagged <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "flag")
  flag <- source
  flag[is.na(num_test)] <- Flagged[is.na(num_test)]
  flag
}

#' Create Imputed ExpressionSet
#'
#' @description
#' Creates an ExpressionSet containing imputed log2 intensity values with CV and CV_flagged.
#'
#' @param datCollate A list containing data collation results
#' @param metadata An AnnotatedDataFrame with sample metadata
#' @param params A list of parameters used in preprocessing
#' @param PSA_list Optional character vector of proteins in PSA list
#'
#' @return An ExpressionSet object with imputed data
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' expset <- ExpSet_create_imputed(datCollate, metadata, params)
#' }
ExpSet_create_imputed <- function(datCollate, metadata, params, PSA_list = NULL) {
  Data <- datCollate$data$Data

  # Create feature data
  features <- ExpSet_create_feature_data(Data, datCollate$data$feature_df, PSA_list)

  # Create matrices
  ImputedlogMeanNetI_all <- Data %>%
    dplyr::filter(!is.na(log2_mean_impute)) %>%
    ExpSet_create_matrix(feature_col = "Protein", value_col = "log2_mean_impute")

  CV <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "cv")

  # # Create CV_flagged: use flag values where num_test is NA, otherwise use cv values
  # num_test <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "num_test")
  # Flagged <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "flag")
  # CV_flagged <- CV
  # CV_flagged[is.na(num_test)] <- Flagged[is.na(num_test)]

  # Create ExpressionSet with ImputedlogMeanNetI_all as initial exprs
  expset <- Biobase::ExpressionSet(
    assayData = ImputedlogMeanNetI_all,
    phenoData = metadata[colnames(ImputedlogMeanNetI_all), ],
    featureData = features[rownames(ImputedlogMeanNetI_all), ]
  )

  # Add all assay data
  Biobase::assayData(expset) <- Biobase::assayDataNew(
    imputed_ImputedlogMeanNetI = ImputedlogMeanNetI_all,
    cv = CV[rownames(ImputedlogMeanNetI_all), colnames(ImputedlogMeanNetI_all)],
    flag = flag_function(Data)[rownames(ImputedlogMeanNetI_all), colnames(ImputedlogMeanNetI_all)]
  )

  expset@experimentData@other$PreProcessingParams <- params
  expset@experimentData@other$AnalysisParams <- list()

  return(expset)
}


#' Create NetI ExpressionSet
#'
#' @description
#' Creates an ExpressionSet containing imputed log2 intensity values for passed samples only.
#'
#' @param datCollate A list containing data collation results
#' @param metadata An AnnotatedDataFrame with sample metadata
#' @param failed_samples Character vector of failed sample names to exclude
#' @param PSA_list Optional character vector of proteins in PSA list
#' @param round_digits Integer. Number of decimal places to round to (default: 3)
#'
#' @return An ExpressionSet object with NetI data for passed samples
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' expset <- ExpSet_create_neti(datCollate, metadata, failed_samples)
#' }
#'
#'
# ExpSet_create_neti <- function(datCollate, metadata, params, failed_samples, PSA_list = NULL, round_digits = 3) {
#   Data <- datCollate$data$Data
#
#   # Create feature data
#   features <- ExpSet_create_feature_data(Data, datCollate$data$feature_df, PSA_list)
#
#   # Create imputed matrix (excluding failed samples)
#   ImputedlogMeanNetI <- Data %>%
#     dplyr::filter(!is.na(log2_mean_impute), !Sample %in% failed_samples) %>%
#     ExpSet_create_matrix(feature_col = "Protein", value_col = "log2_mean_impute")
#
#   # Round values
#   ImputedlogMeanNetI <- round(ImputedlogMeanNetI, round_digits)
#
#   # Create ExpressionSet with ImputedlogMeanNetI as initial exprs
#   expset <- Biobase::ExpressionSet(
#     assayData = ImputedlogMeanNetI,
#     phenoData = metadata[colnames(ImputedlogMeanNetI), ],
#     featureData = features[rownames(ImputedlogMeanNetI), ]
#   )
#
#   # Add all assay data
#   Biobase::assayData(expset) <- Biobase::assayDataNew(
#     NetI_ImputedlogMeanNetI = ImputedlogMeanNetI
#   )
#
#   expset@experimentData@other$PreProcessingParams <- params
#   expset@experimentData@other$AnalysisParams <- list()
#
#   return(expset)
# }
#
ExpSet_create_neti_o <- function(datCollate, metadata, params, failed_samples, PSA_list = NULL, round_digits = 3) {
  Data <- datCollate$data$Data

  # Create feature data
  features <- ExpSet_create_feature_data(Data, datCollate$data$feature_df, PSA_list)

  # Create imputed matrix (excluding failed samples)
  ImputedlogMeanNetI <- Data %>%
    dplyr::filter(!is.na(log2_mean_impute), !Sample %in% failed_samples) %>%
    ExpSet_create_matrix(feature_col = "Protein", value_col = "log2_mean_impute")

  # Round values
  ImputedlogMeanNetI <- round(ImputedlogMeanNetI, round_digits)

  # Create ExpressionSet with ImputedlogMeanNetI as initial exprs
  expset <- Biobase::ExpressionSet(
    assayData = ImputedlogMeanNetI,
    phenoData = metadata[colnames(ImputedlogMeanNetI), ],
    featureData = features[rownames(ImputedlogMeanNetI), ]
  )

  # Add all assay data
  Biobase::assayData(expset) <- Biobase::assayDataNew(
    NetI_ImputedlogMeanNetI_o = ImputedlogMeanNetI
  )

  expset@experimentData@other$PreProcessingParams <- params
  expset@experimentData@other$AnalysisParams <- list()

  return(expset)
}

ExpSet_create_neti <- function(datCollate, metadata, params, failed_samples, PSA_list = NULL, round_digits = 3) {
  Data <- datCollate$data$Data

  # Create feature data
  features <- ExpSet_create_feature_data(Data, datCollate$data$feature_df, PSA_list)

  # Create matrices
  ImputedlogMeanNetI <- Data %>%
    dplyr::filter(!is.na(log2_mean_impute), !Sample %in% failed_samples) %>%
    ExpSet_create_matrix(feature_col = "Protein", value_col = "log2_mean_impute")
  ImputedlogMeanNetI <- round(ImputedlogMeanNetI, round_digits)

  CV <- round(ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "cv"),3)

  # Create CV_flagged: use flag values where num_test is NA, otherwise use cv values
  # num_test <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "num_test")
  # Flagged <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "flag")
  # CV_flagged <- CV
  # CV_flagged[is.na(num_test)] <- Flagged[is.na(num_test)]

  # Create ExpressionSet with ImputedlogMeanNetI_all as initial exprs
  expset <- Biobase::ExpressionSet(
    assayData = ImputedlogMeanNetI,
    phenoData = metadata[colnames(ImputedlogMeanNetI), ],
    featureData = features[rownames(ImputedlogMeanNetI), ]
  )

  # Add all assay data
  Biobase::assayData(expset) <- Biobase::assayDataNew(
    exprs = ImputedlogMeanNetI,
    NetI_ImputedlogMeanNetI = ImputedlogMeanNetI,
    cv = CV[rownames(ImputedlogMeanNetI), colnames(ImputedlogMeanNetI)],
    flag = flag_function(Data)[rownames(ImputedlogMeanNetI), colnames(ImputedlogMeanNetI)]
  )

  expset@experimentData@other$PreProcessingParams <- params
  expset@experimentData@other$AnalysisParams <- list()

  return(expset)
}




#' Create Normalized ExpressionSet
#'
#' @description
#' Creates an ExpressionSet containing normalized intensity values with row-centered data, CV and CV_flagged.
#'
#' @param datCollate A list containing data collation results
#' @param metadata An AnnotatedDataFrame with sample metadata
#' @param params A list of parameters used in preprocessing
#' @param PSA_list Optional character vector of proteins in PSA list
#'
#' @return An ExpressionSet object with normalized data assays
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' expset <- ExpSet_create_norm(datCollate, metadata, params)
#' }
ExpSet_create_norm <- function(datCollate, metadata, params, PSA_list = NULL) {
  output_data <- datCollate$output
  Data <- datCollate$data$Data

  # Create feature data
  features <- ExpSet_create_feature_data(Data, datCollate$data$feature_df, PSA_list)

  # Create matrices
  ImputedlogMeanNetI <- output_data$Imputedlog2MeanNetI %>%
    tibble::column_to_rownames('Protein') %>%
    as.matrix()

  MeanNetI_Normalized <- output_data$MeanNetI_Normalized %>%
    tibble::column_to_rownames('Protein') %>%
    as.matrix() %>%
    .[order(rownames(.)), order(colnames(.))]

  # Row-center the normalized data
  MeanNetI_Normalized_RC <- t(scale(t(MeanNetI_Normalized), scale = FALSE, center = TRUE))

  # Create CV and CV_flagged matrices
  CV <- round(ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "cv"),3)

  # # Create CV_flagged: use flag values where num_test is NA, otherwise use cv values
  # num_test <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "num_test")
  # Flagged <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "flag")
  # CV_flagged <- CV
  # CV_flagged[is.na(num_test)] <- Flagged[is.na(num_test)]

  # Create ExpressionSet with MeanNetI_Normalized as initial exprs
  expset <- Biobase::ExpressionSet(
    assayData = MeanNetI_Normalized,
    phenoData = metadata[colnames(MeanNetI_Normalized), ],
    featureData = features[rownames(MeanNetI_Normalized), ]
  )

  # Add all assay data
  Biobase::assayData(expset) <- Biobase::assayDataNew(
    norm_ImputedlogMeanNetI = ImputedlogMeanNetI[rownames(MeanNetI_Normalized), colnames(MeanNetI_Normalized)],
    norm_MeanNetI_Normalized = MeanNetI_Normalized,
    norm_MeanNetI_Normalized_RC = MeanNetI_Normalized_RC,
    cv = CV[rownames(MeanNetI_Normalized), colnames(MeanNetI_Normalized)],
    flag = flag_function(Data)[rownames(MeanNetI_Normalized), colnames(MeanNetI_Normalized)]
  )

  return(expset)
}


#' Create Clinical ExpressionSet
#'
#' @description
#' Creates an ExpressionSet containing clinical-ready normalized intensity values with metadata, CV and CV_flagged.
#'
#' @param datCollate A list containing data collation results
#' @param metadata An AnnotatedDataFrame with sample metadata
#' @param other A list containing additional metadata to store in experimentData
#' @param PSA_list Optional character vector of proteins in PSA list
#'
#' @return An ExpressionSet object with clinical data assays
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' expset <- ExpSet_create_clinical(datCollate, metadata, other)
#' }
ExpSet_create_clinical <- function(datCollate, metadata, other, PSA_list = NULL) {
  output_data <- datCollate$output
  Data <- datCollate$data$Data

  # Create feature data
  features <- ExpSet_create_feature_data(Data, datCollate$data$feature_df, PSA_list)

  # Create matrices
  ImputedlogMeanNetI <- output_data$Imputedlog2MeanNetI %>%
    tibble::column_to_rownames('Protein') %>%
    as.matrix()

  MeanNetI_Normalized_clinical <- output_data$MeanNetI_Normalized_clinical %>%
    tibble::column_to_rownames('Protein') %>%
    as.matrix() %>%
    .[order(rownames(.)), order(colnames(.))]

  # Row-center the clinical data
  MeanNetI_Normalized_clinical_RC <- t(scale(t(MeanNetI_Normalized_clinical), scale = FALSE, center = TRUE))

  # Create CV and CV_flagged matrices
  CV <- round(ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "cv"),3)

  # Create CV_flagged: use flag values where num_test is NA, otherwise use cv values
  # num_test <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "num_test")
  # Flagged <- ExpSet_create_matrix(Data, feature_col = "Protein", value_col = "flag")
  # CV_flagged <- CV
  # CV_flagged[is.na(num_test)] <- Flagged[is.na(num_test)]

  # Create ExpressionSet with MeanNetI_Normalized_clinical as initial exprs
  expset <- Biobase::ExpressionSet(
    assayData = MeanNetI_Normalized_clinical,
    phenoData = metadata[colnames(MeanNetI_Normalized_clinical), ],
    featureData = features[rownames(MeanNetI_Normalized_clinical), ]
  )

  # Add all assay data
  Biobase::assayData(expset) <- Biobase::assayDataNew(
    clinical_ImputedlogMeanNetI = ImputedlogMeanNetI[rownames(MeanNetI_Normalized_clinical), colnames(MeanNetI_Normalized_clinical)],
    clinical_MeanNetI_Normalized = MeanNetI_Normalized_clinical,
    clinical_MeanNetI_Normalized_RC = MeanNetI_Normalized_clinical_RC,
    cv = CV[rownames(MeanNetI_Normalized_clinical), colnames(MeanNetI_Normalized_clinical)],
    flag = flag_function(Data)[rownames(MeanNetI_Normalized_clinical), colnames(MeanNetI_Normalized_clinical)]
  )

  Biobase::experimentData(expset)@other <- other
  return(expset)
}


#' Create Complete ExpressionSet List
#'
#' @description
#' Creates a complete list of ExpressionSet objects from data collation results.
#'
#' @param dat Data preprocessing list containing param and other elements
#' @param datCollate Data collation list containing data, output, param, and QC elements
#' @param QC QC list containing param, BGFG_stats, Avg_QC (optional)
#' @param project_info Project information to include in metadata (optional)
#' @param PSA_list Optional character vector of proteins in PSA list
#'
#' @return A named list of ExpressionSet objects
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' expset_list <- ExpSet_create_list(dat, datCollate, QC, project_information())
#' }
ExpSet_create_list <- function(dat, datCollate, QC = NULL, project_info = NULL, PSA_list = NULL) {

  # Validate required data exists
  if (is.null(datCollate)) {
    stop("datCollate is required")
  }

  # Build other/metadata structure
  other <- ExpSet_build_other_metadata(dat, datCollate, QC, project_info)

  # Create metadata
  manifest_full <- datCollate$output$manifest
  metadata <- ExpSet_create_metadata(datCollate, manifest_full)

  # Get failed samples for filtering
  failed_samples <- Biobase::pData(metadata) %>%
    dplyr::filter(QC == "Fail") %>%
    rownames()

  # Create parameters list
  params <- list(
    dat = dat$param,
    datCollate = datCollate$param
  )

  # Build all ExpressionSets
  ExpSet_list <- list(
    RawData_ExpSet = ExpSet_create_rawdata(datCollate, metadata, params),
    Mean_ExpSet = ExpSet_create_mean(datCollate, metadata, params, PSA_list),
    Imputed_ExpSet = ExpSet_create_imputed(datCollate, metadata, params, PSA_list),
    NetI_ExpSet = ExpSet_create_neti(datCollate, metadata, params, failed_samples, PSA_list),
    NetI_ExpSet_o = ExpSet_create_neti_o(datCollate, metadata, params, failed_samples, PSA_list)#,
    #norm_ExpSet = ExpSet_create_norm(datCollate, metadata, params, PSA_list),
    #clinical_ExpSet = ExpSet_create_clinical(datCollate, metadata, other, PSA_list)
  )

  return(ExpSet_list)
}


#' Load ExpressionSet from RDS File
#'
#' @description
#' Loads an ExpressionSet or list of ExpressionSets from an RDS file with validation.
#'
#' @param file_path Character. Path to the RDS file
#'
#' @return An ExpressionSet object or list of ExpressionSet objects
#'
#' @note
#' Version 1.0 from ExpSet_functions.R
#'
#' @export
#'
#' @examples
#' \dontrun{
#' expset <- ExpSet_load_from_file("path/to/expset.rds")
#' }
ExpSet_load_from_file <- function(file_path) {

  if (!file.exists(file_path)) {
    stop("File does not exist: ", file_path)
  }

  obj <- readRDS(file_path)

  # Validate it's a valid ExpressionSet or list of ExpressionSets
  if (is.list(obj) && all(sapply(obj, function(x) inherits(x, "ExpressionSet")))) {
    message("Loaded ", length(obj), " ExpressionSets")
    return(obj)
  } else if (inherits(obj, "ExpressionSet")) {
    message("Loaded 1 ExpressionSet")
    return(list(Loaded_ExpSet = obj))
  } else {
    stop("File does not contain valid ExpressionSet object(s)")
  }
}
